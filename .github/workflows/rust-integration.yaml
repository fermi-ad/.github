name: Continuous Integration workflow for Rust apps

on:
  workflow_call:

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  analysis:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Lint
        id: linting
        run: cargo fmt --all -- --check && cargo clippy -- -D warnings
        # Ensures we also run the unit tests even if there are linting errors
        continue-on-error: true
        
      - name: Pull from dependency cache
        uses: actions/cache@v3
        continue-on-error: false
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: ${{ runner.os }}-cargo-

      # Rust relies on a Low-Level Virtual Machine (LLVM) to capture coverage, 
      # and some massaging of the output binary is needed to get an LCOV file. 
      # This tool does that processing for us.
      # NOTE: First checks if grcov is already installed (pulled from cache), and only proceeds if not found
      # The `&> /dev/null` portion ensures the output of `command -v grcov` is discarded 
      - name: Install coverage dependencies
        run: command -v grcov &> /dev/null || cargo install grcov

      - name: Configure rustc so machine code can be read by the coverage reporter
        run: rustup component add llvm-tools
      
      - name: Run tests with coverage (includes building the project)
        run: CARGO_INCREMENTAL=0 RUSTFLAGS='-Cinstrument-coverage' LLVM_PROFILE_FILE='target/cargo-test-%p-%m.profraw' cargo test

      # Breakdown of the command here:
      #
      # grcov ./target                     : Run grcov using profraw files found in the target/ directory
      # --binary-path ./target/debug/deps/ : Path to the compiled binaries
      # -s .                               : Source directory
      # -t lcov                            : Specify output format as lcov
      # --ignore-not-existing              : Ignore files that may be "referenced" in the compiled binaries but don't actually exist on disk (quirk of the LLVM and gcov)
      # --ignore '../*' --ignore "/*"      : Ignore references to Rust stdlib and other crates in $HOME/.cargo/
      # -o target/lcov.info                : Output report to target/lcov.info for use in the next step
      - name: Process raw coverage data into lcov format
        run: grcov ./target --binary-path ./target/debug/deps/ -s . -t lcov --ignore-not-existing --ignore '../*' --ignore "/*" --ignore "target/**" -o target/lcov.info

      - name: Generate coverage report
        uses: fermi-ad/code-coverage-reporter@v1.1.0
        with:
          coverage_file: target/lcov.info
          include_pattern: ^.*\.rs$
          exclude_pattern: target/

      - if: always()
        name: Report linting results
        run: |
          if [ "${{ steps.linting.outcome }}" = "failure" ]; then
            echo "Failure in linting step. See that step's output for details." &> 2
            exit 1
          fi
